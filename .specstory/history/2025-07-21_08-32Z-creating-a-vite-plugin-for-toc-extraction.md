<!-- Generated by SpecStory -->

# Creating a Vite plugin for TOC extraction (2025-07-21 08:32Z)

_**User**_

å†™ä¸€ä¸ªviteæ’ä»¶ï¼Œé€šè¿‡æ­£åˆ™çš„æ–¹å¼è¯»å–mdå’Œmdxæ–‡ä»¶å¹¶æå–å‡ºtocï¼Œä¿å­˜åœ¨ä¸€ä¸ªtsæ–‡ä»¶ä¸­

---

_**Assistant**_

I'll help you create a Vite plugin that extracts table of contents (TOC) from MD and MDX files using regex and saves them to a TypeScript file. Let me first examine the current structure and then implement the plugin. Now let me examine the existing route generator plugin to understand the pattern and structure: Let me look at the full structure of the route generator plugin to understand the pattern: Now let me examine the TOC extractor mentioned in the vite config to understand the current structure: Now I have a good understanding of the project structure and requirements. Let me create a TOC extractor plugin for extracting table of contents from MD and MDX files using regex and saving them to a TypeScript file.

````typescript
import fs from 'node:fs/promises'
import path from 'node:path'

import { glob } from 'glob'
import type { Plugin } from 'vite'

interface TocItem {
  id: string
  level: number
  text: string
  children?: TocItem[]
}

interface FileToc {
  file: string
  title: string
  toc: TocItem[]
}

interface TocExtractorOptions {
  contentsDir?: string
  outputDir?: string
  outputFile?: string
  maxDepth?: number
}

const defaultOptions: Required<TocExtractorOptions> = {
  contentsDir: 'contents',
  outputDir: 'src',
  outputFile: 'toc-data.ts',
  maxDepth: 6,
}

/**
 * TOC æå–å™¨æ’ä»¶
 *
 * é€šè¿‡æ­£åˆ™è¡¨è¾¾å¼ä» MD å’Œ MDX æ–‡ä»¶ä¸­æå–æ ‡é¢˜ï¼Œç”Ÿæˆç›®å½•ç»“æ„
 * å¹¶ä¿å­˜åˆ° TypeScript æ–‡ä»¶ä¸­
 */
export function tocExtractor(options: TocExtractorOptions = {}): Plugin {
  const opts = { ...defaultOptions, ...options }

  return {
    name: 'toc-extractor',
    enforce: 'pre',

    async buildStart() {
      await generateTocData(opts)
    },

    async handleHotUpdate({ file, server }) {
      // ç›‘å¬ contents ç›®å½•æ–‡ä»¶å˜åŒ–ï¼Œé‡æ–°ç”Ÿæˆ TOC æ•°æ®
      if (file.includes(path.resolve(opts.contentsDir))) {
        await generateTocData(opts)
        server.ws.send({
          type: 'full-reload',
        })
      }
    },

    configureServer(server) {
      // å¼€å‘æ¨¡å¼ä¸‹æä¾›æ‰‹åŠ¨è§¦å‘æ¥å£
      server.middlewares.use('/__generate-toc', async (_req, res) => {
        try {
          await generateTocData(opts)
          res.end('TOC data generated successfully')
        } catch (error) {
          res.statusCode = 500
          res.end(`Error generating TOC data: ${error}`)
        }
      })
    },
  }
}

async function generateTocData(options: Required<TocExtractorOptions>) {
  const { contentsDir, outputDir, outputFile, maxDepth } = options

  try {
    // è·å–æ‰€æœ‰ markdown æ–‡ä»¶
    const pattern = path.join(contentsDir, '**/*.{md,mdx}')
    const files = await glob(pattern, {
      ignore: ['**/node_modules/**'],
      absolute: false,
    })

    const allTocData: FileToc[] = []

    for (const file of files) {
      const tocData = await extractTocFromFile(file, contentsDir, maxDepth)
      if (tocData) {
        allTocData.push(tocData)
      }
    }

    // æŒ‰æ–‡ä»¶è·¯å¾„æ’åº
    allTocData.sort((a, b) => a.file.localeCompare(b.file))

    // ç”Ÿæˆ TypeScript æ–‡ä»¶å†…å®¹
    const tsContent = generateTocTsContent(allTocData)

    // ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
    await fs.mkdir(outputDir, { recursive: true })

    // å†™å…¥æ–‡ä»¶
    const outputPath = path.join(outputDir, outputFile)
    await fs.writeFile(outputPath, tsContent, 'utf-8')

    console.info(
      `âœ“ Generated TOC data for ${allTocData.length} files to ${outputPath}`,
    )
  } catch (error) {
    console.error('Error generating TOC data:', error)
    throw error
  }
}

async function extractTocFromFile(
  file: string,
  contentsDir: string,
  maxDepth: number,
): Promise<FileToc | null> {
  try {
    const content = await fs.readFile(file, 'utf-8')

    // æå– frontmatter ä¸­çš„æ ‡é¢˜
    const frontmatterTitle = extractFrontmatterTitle(content)

    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æå–æ ‡é¢˜
    const headings = extractHeadings(content, maxDepth)

    if (headings.length === 0 && !frontmatterTitle) {
      return null
    }

    // æ„å»ºåµŒå¥—çš„ TOC ç»“æ„
    const toc = buildTocTree(headings)

    // ç”Ÿæˆæ–‡ä»¶è·¯å¾„ï¼ˆç›¸å¯¹äº contents ç›®å½•ï¼‰
    const relativePath = path.relative(contentsDir, file)

    return {
      file: relativePath,
      title: frontmatterTitle || headings[0]?.text || path.basename(file, path.extname(file)),
      toc,
    }
  } catch (error) {
    console.warn(`Failed to process file ${file}:`, error)
    return null
  }
}

function extractFrontmatterTitle(content: string): string | null {
  // åŒ¹é… frontmatter ä¸­çš„ title å­—æ®µ
  const frontmatterMatch = content.match(/^---\n(.*?)\n---/s)
  if (!frontmatterMatch) return null

  const frontmatterContent = frontmatterMatch[1]
  const titleMatch = frontmatterContent.match(/^title:\s*(.+)$/m)
  if (!titleMatch) return null

  // ç§»é™¤å¼•å·
  return titleMatch[1].replace(/^['"]|['"]$/g, '').trim()
}

function extractHeadings(content: string, maxDepth: number): TocItem[] {
  const headings: TocItem[] = []
  
  // æ­£åˆ™è¡¨è¾¾å¼åŒ¹é… Markdown æ ‡é¢˜ (## Title æ ¼å¼)
  const headingRegex = /^(#{1,6})\s+(.+)$/gm
  
  let match
  while ((match = headingRegex.exec(content)) !== null) {
    const level = match[1].length
    
    if (level > maxDepth) continue
    
    const text = match[2].trim()
    
    // ç”Ÿæˆ IDï¼ˆè½¬æ¢ä¸ºå°å†™ï¼Œæ›¿æ¢ç©ºæ ¼å’Œç‰¹æ®Šå­—ç¬¦ï¼‰
    const id = generateHeadingId(text)
    
    headings.push({
      id,
      level,
      text,
    })
  }
  
  return headings
}

function generateHeadingId(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^\w\s-]/g, '') // ç§»é™¤ç‰¹æ®Šå­—ç¬¦
    .replace(/\s+/g, '-') // ç©ºæ ¼æ›¿æ¢ä¸ºè¿å­—ç¬¦
    .replace(/-+/g, '-') // å¤šä¸ªè¿å­—ç¬¦åˆå¹¶ä¸ºä¸€ä¸ª
    .replace(/^-|-$/g, '') // ç§»é™¤å¼€å¤´å’Œç»“å°¾çš„è¿å­—ç¬¦
}

function buildTocTree(headings: TocItem[]): TocItem[] {
  const result: TocItem[] = []
  const stack: TocItem[] = []

  for (const heading of headings) {
    // å°†å½“å‰æ ‡é¢˜çš„å­å…ƒç´ åˆå§‹åŒ–ä¸ºç©ºæ•°ç»„
    heading.children = []

    // æ‰¾åˆ°åˆé€‚çš„çˆ¶çº§
    while (stack.length > 0 && stack[stack.length - 1].level >= heading.level) {
      stack.pop()
    }

    if (stack.length === 0) {
      // é¡¶çº§æ ‡é¢˜
      result.push(heading)
    } else {
      // ä½œä¸ºå­æ ‡é¢˜
      const parent = stack[stack.length - 1]
      if (!parent.children) {
        parent.children = []
      }
      parent.children.push(heading)
    }

    stack.push(heading)
  }

  return result
}

function generateTocTsContent(tocData: FileToc[]): string {
  return `// This file is automatically generated by the toc-extractor plugin
// Do not edit manually

export interface TocItem {
  id: string
  level: number
  text: string
  children?: TocItem[]
}

export interface FileToc {
  file: string
  title: string
  toc: TocItem[]
}

export const tocData: FileToc[] = ${JSON.stringify(tocData, null, 2)}

// Helper function to find TOC data by file path
export function getTocByFile(filePath: string): FileToc | undefined {
  return tocData.find(item => item.file === filePath)
}

// Helper function to flatten TOC tree into a simple array
export function flattenToc(toc: TocItem[]): TocItem[] {
  const result: TocItem[] = []
  
  function traverse(items: TocItem[]) {
    for (const item of items) {
      result.push({
        id: item.id,
        level: item.level,
        text: item.text,
      })
      if (item.children && item.children.length > 0) {
        traverse(item.children)
      }
    }
  }
  
  traverse(toc)
  return result
}

// Helper function to get all headings at a specific level
export function getHeadingsByLevel(toc: TocItem[], level: number): TocItem[] {
  const result: TocItem[] = []
  
  function traverse(items: TocItem[]) {
    for (const item of items) {
      if (item.level === level) {
        result.push(item)
      }
      if (item.children && item.children.length > 0) {
        traverse(item.children)
      }
    }
  }
  
  traverse(toc)
  return result
}
`
}

export default tocExtractor
````

è¿™ä¸ª TOC æå–å™¨æ’ä»¶å…·æœ‰ä»¥ä¸‹åŠŸèƒ½ï¼š

## ğŸŒŸ æ ¸å¿ƒç‰¹æ€§

### 1. **æ­£åˆ™è¡¨è¾¾å¼è§£æ**
- ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ `/^(#{1,6})\s+(.+)$/gm` åŒ¹é… Markdown æ ‡é¢˜
- æ”¯æŒ 1-6 çº§æ ‡é¢˜ï¼ˆ# åˆ° ######ï¼‰
- è‡ªåŠ¨ç”Ÿæˆå”¯ä¸€çš„æ ‡é¢˜ ID

### 2. **æ–‡ä»¶ç±»å‹æ”¯æŒ**
- æ”¯æŒ `.md` å’Œ `.mdx` æ–‡ä»¶
- è‡ªåŠ¨æå– frontmatter ä¸­çš„ `title` å­—æ®µ
- é€’å½’æ‰«æ `contents` ç›®å½•

### 3. **åµŒå¥—ç»“æ„æ„å»º**
- æ ¹æ®æ ‡é¢˜çº§åˆ«æ„å»ºåµŒå¥—çš„ TOC æ ‘ç»“æ„
- æ”¯æŒå¤šçº§åµŒå¥—ï¼ˆå­æ ‡é¢˜å…³ç³»ï¼‰
- ä¿æŒæ ‡é¢˜çš„å±‚çº§å…³ç³»

### 4. **TypeScript è¾“å‡º**
- ç”Ÿæˆå®Œæ•´çš„ TypeScript ç±»å‹å®šä¹‰
- å¯¼å‡ºæ‰€æœ‰ TOC æ•°æ®å’Œè¾…åŠ©å‡½æ•°
- è‡ªåŠ¨ç”Ÿæˆæ³¨é‡Šè¯´æ˜

## ğŸ”§ é…ç½®é€‰é¡¹

```typescript
interface TocExtractorOptions {
  contentsDir?: string    // å†…å®¹ç›®å½•ï¼Œé»˜è®¤ 'contents'
  outputDir?: string      // è¾“å‡ºç›®å½•ï¼Œé»˜è®¤ 'src'
  outputFile?: string     // è¾“å‡ºæ–‡ä»¶åï¼Œé»˜è®¤ 'toc-data.ts'
  maxDepth?: number       // æœ€å¤§æ ‡é¢˜æ·±åº¦ï¼Œé»˜è®¤ 6
}
```

## ğŸ“š ä½¿ç”¨æ–¹å¼

æ’ä»¶ä¼šç”Ÿæˆä¸€ä¸ªåŒ…å«ä»¥ä¸‹å†…å®¹çš„ TypeScript æ–‡ä»¶ï¼š

1. **ç±»å‹å®šä¹‰**ï¼š`TocItem` å’Œ `FileToc` æ¥å£
2. **æ•°æ®å¯¼å‡º**ï¼šæ‰€æœ‰æ–‡ä»¶çš„ TOC æ•°æ®
3. **è¾…åŠ©å‡½æ•°**ï¼š
   - `getTocByFile()` - æ ¹æ®æ–‡ä»¶è·¯å¾„æŸ¥æ‰¾ TOC
   - `flattenToc()` - å°†åµŒå¥— TOC è½¬ä¸ºå¹³é¢æ•°ç»„
   - `getHeadingsByLevel()` - è·å–ç‰¹å®šçº§åˆ«çš„æ ‡é¢˜

## ğŸš€ çƒ­æ›´æ–°æ”¯æŒ

- å¼€å‘æ¨¡å¼ä¸‹ç›‘å¬æ–‡ä»¶å˜åŒ–
- è‡ªåŠ¨é‡æ–°ç”Ÿæˆ TOC æ•°æ®
- æ”¯æŒæ‰‹åŠ¨è§¦å‘æ›´æ–°ï¼ˆ`/__generate-toc` æ¥å£ï¼‰

è¿™ä¸ªæ’ä»¶å·²ç»é›†æˆåˆ° `vite.config.ts` ä¸­ï¼Œä¼šåœ¨æ„å»ºæ—¶å’Œå¼€å‘æ—¶è‡ªåŠ¨è¿è¡Œï¼Œä¸ºæ–‡æ¡£ç«™ç‚¹æä¾›å®Œæ•´çš„ç›®å½•ç»“æ„æ•°æ®ã€‚

---

_**User**_

æ ¹æ®æ–°çš„tocç»“æ„é‡æ–°ç¼–å†™è¿™é‡Œ

---

_**Assistant**_

æˆ‘çœ‹åˆ°å½“å‰çš„ `TableOfContents` ç»„ä»¶æœ‰ä¸€äº›é—®é¢˜éœ€è¦ä¿®å¤ï¼Œä»¥é€‚åº”æ–°çš„ TOC ç»“æ„ã€‚è®©æˆ‘åˆ†æä¸€ä¸‹é—®é¢˜å¹¶é‡æ–°ç¼–å†™è¿™ä¸ªç»„ä»¶ã€‚ 

---

_**User**_

@GitHubCopilot Try Again

---

_**Assistant**_



---

_**User**_

@GitHubCopilot Try Again

---

_**Assistant**_

æˆ‘çœ‹åˆ°å½“å‰çš„ `TableOfContents` ç»„ä»¶éœ€è¦æ ¹æ®æ–°çš„ TOC ç»“æ„è¿›è¡Œé‡æ–°ç¼–å†™ã€‚è®©æˆ‘åˆ†æé—®é¢˜å¹¶æä¾›å®Œæ•´çš„è§£å†³æ–¹æ¡ˆã€‚ ç°åœ¨è®©æˆ‘æ£€æŸ¥å½“å‰ç”Ÿæˆçš„ TOC æ•°æ®ç»“æ„ï¼š ç°åœ¨è®©æˆ‘æ£€æŸ¥å½“å‰è·¯ç”±ç³»ç»Ÿæ¥è·å–å½“å‰é¡µé¢ä¿¡æ¯ï¼š å¥½ï¼Œæˆ‘æ‰¾åˆ°äº†è·¯ç”±ç³»ç»Ÿçš„ç»“æ„ã€‚è¿™ä¸ªæ–‡æ¡£ç«™ç‚¹ä½¿ç”¨çš„æ˜¯è‡ªå®šä¹‰çš„è·¯ç”±ç³»ç»Ÿï¼Œå½“å‰è·¯å¾„é€šè¿‡ `currentPath` prop ä¼ é€’åˆ° `TableOfContents` ç»„ä»¶ä¸­ã€‚ç°åœ¨è®©æˆ‘é‡æ–°ç¼–å†™ `TableOfContents.tsx` ç»„ä»¶ï¼š ç°åœ¨æˆ‘æ¥é‡æ–°ç¼–å†™ `TableOfContents.tsx` ç»„ä»¶ï¼Œä½¿å…¶æ”¯æŒæ–°çš„åµŒå¥— TOC ç»“æ„ï¼š

````typescript
import { useEffect, useState } from 'react'
import { tocData, getTocByFile, type TocItem } from '../toc-data'

interface TableOfContentsProps {
  currentPath: string
}

interface TocItemProps {
  item: TocItem
  activeId: string | null
  level: number
}

function TocItemComponent({ item, activeId, level }: TocItemProps) {
  const isActive = activeId === item.id
  const hasChildren = item.children && item.children.length > 0
  
  return (
    <li className="relative">
      <a
        href={`#${item.id}`}
        className={`
          block py-1 text-sm transition-colors duration-200
          ${isActive 
            ? 'text-blue-600 font-medium border-l-2 border-blue-600 pl-3' 
            : 'text-gray-600 hover:text-gray-900 pl-3'
          }
          ${level > 1 ? `ml-${(level - 1) * 4}` : ''}
        `}
        onClick={(e) => {
          e.preventDefault()
          const element = document.getElementById(item.id)
          if (element) {
            element.scrollIntoView({ behavior: 'smooth', block: 'start' })
          }
        }}
      >
        {item.text}
      </a>
      
      {hasChildren && (
        <ul className="mt-1 space-y-1">
          {item.children!.map((child) => (
            <TocItemComponent
              key={child.id}
              item={child}
              activeId={activeId}
              level={level + 1}
            />
          ))}
        </ul>
      )}
    </li>
  )
}

export function TableOfContents({
  currentPath,
}: TableOfContentsProps) {
  const [activeId, setActiveId] = useState<string | null>(null)
  
  // è·å–å½“å‰é¡µé¢çš„ TOC æ•°æ®
  const currentToc = getTocByFile(currentPath)
  
  // ç›‘å¬æ»šåŠ¨ï¼Œé«˜äº®å½“å‰æ ‡é¢˜
  useEffect(() => {
    if (!currentToc || currentToc.length === 0) return
    
    const observer = new IntersectionObserver(
      (entries) => {
        // æ‰¾åˆ°å¯è§çš„æ ‡é¢˜ä¸­æœ€ä¸Šé¢çš„ä¸€ä¸ª
        const visibleEntries = entries.filter((entry) => entry.isIntersecting)
        if (visibleEntries.length > 0) {
          // æŒ‰ç…§åœ¨é¡µé¢ä¸­çš„ä½ç½®æ’åºï¼Œé€‰æ‹©æœ€ä¸Šé¢çš„
          visibleEntries.sort((a, b) => {
            const aRect = a.boundingClientRect
            const bRect = b.boundingClientRect
            return aRect.top - bRect.top
          })
          setActiveId(visibleEntries[0].target.id)
        }
      },
      {
        rootMargin: '-20px 0px -80% 0px',
        threshold: 0.1,
      }
    )
    
    // è·å–æ‰€æœ‰æ ‡é¢˜IDï¼ˆåŒ…æ‹¬åµŒå¥—çš„ï¼‰
    const getAllIds = (items: TocItem[]): string[] => {
      const ids: string[] = []
      for (const item of items) {
        ids.push(item.id)
        if (item.children) {
          ids.push(...getAllIds(item.children))
        }
      }
      return ids
    }
    
    const allIds = getAllIds(currentToc)
    
    // è§‚å¯Ÿæ‰€æœ‰æ ‡é¢˜å…ƒç´ 
    allIds.forEach((id) => {
      const element = document.getElementById(id)
      if (element) {
        observer.observe(element)
      }
    })
    
    return () => {
      observer.disconnect()
    }
  }, [currentToc])
  
  // å¦‚æœå½“å‰é¡µé¢æ²¡æœ‰TOCæ•°æ®ï¼Œä¸æ˜¾ç¤º
  if (!currentToc || currentToc.length === 0) {
    return null
  }
  
  return (
    <div className="sticky top-8 max-h-[calc(100vh-4rem)] overflow-auto">
      <div className="mb-4">
        <h4 className="text-sm font-semibold text-gray-900 mb-3">
          Table of Contents
        </h4>
        
        <nav>
          <ul className="space-y-1">
            {currentToc.map((item) => (
              <TocItemComponent
                key={item.id}
                item={item}
                activeId={activeId}
                level={1}
              />
            ))}
          </ul>
        </nav>
      </div>
    </div>
  )
}
````

è¿™ä¸ªé‡æ–°ç¼–å†™çš„ç»„ä»¶å…·æœ‰ä»¥ä¸‹ç‰¹æ€§ï¼š

1. **åµŒå¥— TOC æ¸²æŸ“**ï¼šä½¿ç”¨é€’å½’çš„ `TocItemComponent` æ¥æ¸²æŸ“åµŒå¥—çš„æ ‡é¢˜ç»“æ„
2. **å½“å‰é¡µé¢æ£€æµ‹**ï¼šä½¿ç”¨ `getTocByFile(currentPath)` è·å–å½“å‰é¡µé¢çš„ TOC æ•°æ®
3. **æ´»åŠ¨æ ‡é¢˜é«˜äº®**ï¼šä½¿ç”¨ `IntersectionObserver` ç›‘å¬æ»šåŠ¨ï¼Œè‡ªåŠ¨é«˜äº®å½“å‰å¯è§çš„æ ‡é¢˜
4. **å¹³æ»‘æ»šåŠ¨**ï¼šç‚¹å‡» TOC é“¾æ¥æ—¶ä½¿ç”¨å¹³æ»‘æ»šåŠ¨åˆ°å¯¹åº”æ ‡é¢˜
5. **å±‚çº§ç¼©è¿›**ï¼šä¸åŒå±‚çº§çš„æ ‡é¢˜ä½¿ç”¨ä¸åŒçš„ç¼©è¿›ï¼Œè§†è§‰ä¸Šæ›´æ¸…æ™°
6. **å“åº”å¼è®¾è®¡**ï¼šæ”¯æŒç²˜æ€§å®šä½å’Œæœ€å¤§é«˜åº¦é™åˆ¶ï¼Œé¿å… TOC è¿‡é•¿æ—¶çš„é—®é¢˜

ä¸»è¦æ”¹è¿›ï¼š

- **æ•°æ®è·å–**ï¼šä» `tocData` æ”¹ä¸ºä½¿ç”¨ `getTocByFile(currentPath)` è·å–å½“å‰é¡µé¢çš„ TOC
- **åµŒå¥—æ”¯æŒ**ï¼šé€’å½’æ¸²æŸ“ `item.children`ï¼Œæ”¯æŒå¤šå±‚åµŒå¥—
- **ID æ”¶é›†**ï¼šé€’å½’æ”¶é›†æ‰€æœ‰åµŒå¥—çš„æ ‡é¢˜ ID ç”¨äºæ»šåŠ¨ç›‘å¬
- **è§†è§‰å±‚æ¬¡**ï¼šä½¿ç”¨ç¼©è¿›å’Œé¢œè‰²åŒºåˆ†ä¸åŒå±‚çº§çš„æ ‡é¢˜

è¿™æ ·çš„ç»„ä»¶å¯ä»¥å®Œç¾åœ°é…åˆæˆ‘ä»¬ä¹‹å‰åˆ›å»ºçš„ TOC æå–æ’ä»¶å’Œç”Ÿæˆçš„åµŒå¥—æ•°æ®ç»“æ„ä½¿ç”¨ã€‚

---

_**User**_

å‚è€ƒpathçš„ç”Ÿæˆ #file:route-generater.ts ï¼Œæ·»åŠ ä¸€ä¸ªpathå‚æ•°ä»¥ä¾¿å¯¹åº”ä¸Š

---

_**Assistant**_

æˆ‘çœ‹åˆ°ä½ å¸Œæœ›åœ¨ TOC æå–å™¨ä¸­æ·»åŠ ä¸€ä¸ª `path` å‚æ•°ï¼Œä»¥ä¾¿ä¸è·¯ç”±ç”Ÿæˆå™¨çš„è·¯å¾„ç”Ÿæˆé€»è¾‘ä¿æŒä¸€è‡´ã€‚è®©æˆ‘åˆ†æè·¯ç”±ç”Ÿæˆå™¨çš„è·¯å¾„ç”Ÿæˆé€»è¾‘ï¼Œç„¶ååœ¨ TOC æå–å™¨ä¸­æ·»åŠ ç›¸åº”çš„åŠŸèƒ½ã€‚ ç°åœ¨æˆ‘ç†è§£äº†è·¯ç”±ç”Ÿæˆå™¨çš„è·¯å¾„ç”Ÿæˆé€»è¾‘ã€‚è®©æˆ‘ä¿®æ”¹ TOC æå–å™¨ï¼Œæ·»åŠ ä¸€ä¸ª `path` å‚æ•°ï¼Œå¹¶ä½¿ç”¨ä¸è·¯ç”±ç”Ÿæˆå™¨ç›¸åŒçš„è·¯å¾„ç”Ÿæˆé€»è¾‘ï¼š

````typescript
import fs from 'node:fs/promises'
import path from 'node:path'

import { glob } from 'glob'
import type { Plugin } from 'vite'

interface TocItem {
  id: string
  level: number
  text: string
  children?: TocItem[]
}

interface FileToc {
  file: string
  path: string
  title: string
  toc: TocItem[]
}

interface TocExtractorOptions {
  contentsDir?: string
  outputDir?: string
  outputFile?: string
  maxDepth?: number
  indexFile?: string
}

const defaultOptions: Required<TocExtractorOptions> = {
  contentsDir: 'contents',
  outputDir: 'src',
  outputFile: 'toc-data.ts',
  maxDepth: 6,
  indexFile: 'index',
}

/**
 * TOC æå–å™¨æ’ä»¶
 *
 * é€šè¿‡æ­£åˆ™è¡¨è¾¾å¼ä» MD å’Œ MDX æ–‡ä»¶ä¸­æå–æ ‡é¢˜ï¼Œç”Ÿæˆç›®å½•ç»“æ„
 * å¹¶ä¿å­˜åˆ° TypeScript æ–‡ä»¶ä¸­
 */
export function tocExtractor(options: TocExtractorOptions = {}): Plugin {
  const opts = { ...defaultOptions, ...options }

  return {
    name: 'toc-extractor',
    enforce: 'pre',

    async buildStart() {
      await generateTocData(opts)
    },

    async handleHotUpdate({ file, server }) {
      // ç›‘å¬ contents ç›®å½•æ–‡ä»¶å˜åŒ–ï¼Œé‡æ–°ç”Ÿæˆ TOC æ•°æ®
      if (file.includes(path.resolve(opts.contentsDir))) {
        await generateTocData(opts)
        server.ws.send({
          type: 'full-reload',
        })
      }
    },

    configureServer(server) {
      // å¼€å‘æ¨¡å¼ä¸‹æä¾›æ‰‹åŠ¨è§¦å‘æ¥å£
      server.middlewares.use('/__generate-toc', async (_req, res) => {
        try {
          await generateTocData(opts)
          res.end('TOC data generated successfully')
        } catch (error) {
          res.statusCode = 500
          res.end(`Error generating TOC data: ${error}`)
        }
      })
    },
  }
}

async function generateTocData(options: Required<TocExtractorOptions>) {
  const { contentsDir, outputDir, outputFile, maxDepth, indexFile } = options

  try {
    // è·å–æ‰€æœ‰ markdown æ–‡ä»¶
    const pattern = path.join(contentsDir, '**/*.{md,mdx}')
    const files = await glob(pattern, {
      ignore: ['**/node_modules/**'],
      absolute: false,
    })

    const allTocData: FileToc[] = []

    for (const file of files) {
      const tocData = await extractTocFromFile(file, contentsDir, maxDepth, indexFile)
      if (tocData) {
        allTocData.push(tocData)
      }
    }

    // æŒ‰è·¯å¾„æ’åº
    allTocData.sort((a, b) => a.path.localeCompare(b.path))

    // ç”Ÿæˆ TypeScript æ–‡ä»¶å†…å®¹
    const tsContent = generateTocTsContent(allTocData)

    // ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
    await fs.mkdir(outputDir, { recursive: true })

    // å†™å…¥æ–‡ä»¶
    const outputPath = path.join(outputDir, outputFile)
    await fs.writeFile(outputPath, tsContent, 'utf-8')

    console.info(
      `âœ“ Generated TOC data for ${allTocData.length} files to ${outputPath}`,
    )
  } catch (error) {
    console.error('Error generating TOC data:', error)
    throw error
  }
}

async function extractTocFromFile(
  file: string,
  contentsDir: string,
  maxDepth: number,
  indexFile: string,
): Promise<FileToc | null> {
  try {
    const content = await fs.readFile(file, 'utf-8')

    // æå– frontmatter ä¸­çš„æ ‡é¢˜
    const frontmatterTitle = extractFrontmatterTitle(content)

    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æå–æ ‡é¢˜
    const headings = extractHeadings(content, maxDepth)

    if (headings.length === 0 && !frontmatterTitle) {
      return null
    }

    // æ„å»ºåµŒå¥—çš„ TOC ç»“æ„
    const toc = buildTocTree(headings)

    // ç”Ÿæˆæ–‡ä»¶è·¯å¾„ï¼ˆç›¸å¯¹äº contents ç›®å½•ï¼‰
    const relativePath = path.relative(contentsDir, file)

    // ç”Ÿæˆè·¯ç”±è·¯å¾„ï¼ˆä¸ route-generator ä¿æŒä¸€è‡´ï¼‰
    const routePath = generateRoutePath(file, contentsDir, indexFile)

    return {
      file: relativePath,
      path: routePath,
      title:
        frontmatterTitle ||
        headings[0]?.text ||
        path.basename(file, path.extname(file)),
      toc,
    }
  } catch (error) {
    console.warn(`Failed to process file ${file}:`, error)
    return null
  }
}

function generateRoutePath(file: string, contentsDir: string, indexFile: string): string {
  // ç§»é™¤ contents å‰ç¼€å’Œæ–‡ä»¶æ‰©å±•åï¼ˆä¸ route-generator ä¿æŒä¸€è‡´ï¼‰
  let routePath = file
    .replace(new RegExp(`^${contentsDir}/`), '')
    .replace(/\.(md|mdx)$/, '')

  // å¤„ç† index æ–‡ä»¶ï¼ˆä¸ route-generator ä¿æŒä¸€è‡´ï¼‰
  if (routePath === indexFile) {
    routePath = '/'
  } else if (routePath.endsWith(`/${indexFile}`)) {
    const basePath = routePath.replace(`/${indexFile}`, '')
    routePath = basePath ? `/${basePath}` : '/'
  } else {
    routePath = `/${routePath}`
  }

  return routePath
}

function extractFrontmatterTitle(content: string): string | null {
  // åŒ¹é… frontmatter ä¸­çš„ title å­—æ®µ
  const frontmatterMatch = content.match(/^---\n(.*?)\n---/s)
  if (!frontmatterMatch) return null

  const frontmatterContent = frontmatterMatch[1]
  const titleMatch = frontmatterContent.match(/^title:\s*(.+)$/m)
  if (!titleMatch) return null

  // ç§»é™¤å¼•å·
  return titleMatch[1].replace(/^['"]|['"]$/g, '').trim()
}

function extractHeadings(content: string, maxDepth: number): TocItem[] {
  const headings: TocItem[] = []

  // æ­£åˆ™è¡¨è¾¾å¼åŒ¹é… Markdown æ ‡é¢˜ (## Title æ ¼å¼)
  const headingRegex = /^(#{1,6})\s+(.+)$/gm

  let match
  while ((match = headingRegex.exec(content)) !== null) {
    const level = match[1].length

    if (level > maxDepth) continue

    const text = match[2].trim()

    // ç”Ÿæˆ IDï¼ˆè½¬æ¢ä¸ºå°å†™ï¼Œæ›¿æ¢ç©ºæ ¼å’Œç‰¹æ®Šå­—ç¬¦ï¼‰
    const id = generateHeadingId(text)

    headings.push({
      id,
      level,
      text,
    })
  }

  return headings
}

function generateHeadingId(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^\w\s-]/g, '') // ç§»é™¤ç‰¹æ®Šå­—ç¬¦
    .replace(/\s+/g, '-') // ç©ºæ ¼æ›¿æ¢ä¸ºè¿å­—ç¬¦
    .replace(/-+/g, '-') // å¤šä¸ªè¿å­—ç¬¦åˆå¹¶ä¸ºä¸€ä¸ª
    .replace(/^-|-$/g, '') // ç§»é™¤å¼€å¤´å’Œç»“å°¾çš„è¿å­—ç¬¦
}

function buildTocTree(headings: TocItem[]): TocItem[] {
  const result: TocItem[] = []
  const stack: TocItem[] = []

  for (const heading of headings) {
    // å°†å½“å‰æ ‡é¢˜çš„å­å…ƒç´ åˆå§‹åŒ–ä¸ºç©ºæ•°ç»„
    heading.children = []

    // æ‰¾åˆ°åˆé€‚çš„çˆ¶çº§
    while (stack.length > 0 && stack[stack.length - 1].level >= heading.level) {
      stack.pop()
    }

    if (stack.length === 0) {
      // é¡¶çº§æ ‡é¢˜
      result.push(heading)
    } else {
      // ä½œä¸ºå­æ ‡é¢˜
      const parent = stack[stack.length - 1]
      if (!parent.children) {
        parent.children = []
      }
      parent.children.push(heading)
    }

    stack.push(heading)
  }

  return result
}

function generateTocTsContent(tocData: FileToc[]): string {
  return `// This file is automatically generated by the toc-extractor plugin
// Do not edit manually

export interface TocItem {
  id: string
  level: number
  text: string
  children?: TocItem[]
}

export interface FileToc {
  file: string
  path: string
  title: string
  toc: TocItem[]
}

export const tocData: FileToc[] = ${JSON.stringify(tocData, null, 2)}

// Helper function to find TOC data by file path
export function getTocByFile(filePath: string): TocItem[] | undefined {
  const item = tocData.find(item => item.file === filePath)
  return item?.toc
}

// Helper function to find TOC data by route path
export function getTocByPath(routePath: string): TocItem[] | undefined {
  const item = tocData.find(item => item.path === routePath)
  return item?.toc
}

// Helper function to flatten TOC tree into a simple array
export function flattenToc(toc: TocItem[]): TocItem[] {
  const result: TocItem[] = []
  
  function traverse(items: TocItem[]) {
    for (const item of items) {
      result.push({
        id: item.id,
        level: item.level,
        text: item.text,
      })
      if (item.children && item.children.length > 0) {
        traverse(item.children)
      }
    }
  }
  
  traverse(toc)
  return result
}

// Helper function to get all headings at a specific level
export function getHeadingsByLevel(toc: TocItem[], level: number): TocItem[] {
  const result: TocItem[] = []
  
  function traverse(items: TocItem[]) {
    for (const item of items) {
      if (item.level === level) {
        result.push(item)
      }
      if (item.children && item.children.length > 0) {
        traverse(item.children)
      }
    }
  }
  
  traverse(toc)
  return result
}
`
}

export default tocExtractor
````

ä¸»è¦ä¿®æ”¹å†…å®¹ï¼š

1. **æ·»åŠ  `path` å­—æ®µ**ï¼šåœ¨ `FileToc` æ¥å£ä¸­æ·»åŠ äº† `path` å­—æ®µï¼Œç”¨äºå­˜å‚¨è·¯ç”±è·¯å¾„

2. **æ·»åŠ  `indexFile` é…ç½®**ï¼šåœ¨ `TocExtractorOptions` ä¸­æ·»åŠ äº† `indexFile` å‚æ•°ï¼Œé»˜è®¤å€¼ä¸º `'index'`

3. **æ–°å¢ `generateRoutePath` å‡½æ•°**ï¼šå®Œå…¨å¤åˆ¶äº†è·¯ç”±ç”Ÿæˆå™¨ä¸­çš„è·¯å¾„ç”Ÿæˆé€»è¾‘ï¼Œç¡®ä¿è·¯å¾„ç”Ÿæˆè§„åˆ™ä¸€è‡´ï¼š
   - `contents/index.md` â†’ `/`
   - `contents/guide.md` â†’ `/guide`
   - `contents/api/index.md` â†’ `/api`
   - `contents/api/auth.md` â†’ `/api/auth`

4. **æ›´æ–° helper å‡½æ•°**ï¼š
   - ä¿®æ”¹ `getTocByFile` è¿”å›ç±»å‹ä¸º `TocItem[]` è€Œä¸æ˜¯ `FileToc`
   - æ–°å¢ `getTocByPath` å‡½æ•°ï¼Œå…è®¸é€šè¿‡è·¯ç”±è·¯å¾„æŸ¥æ‰¾ TOC æ•°æ®

5. **æ’åºè°ƒæ•´**ï¼šå°†æ’åºæ”¹ä¸ºæŒ‰ `path` è€Œä¸æ˜¯ `file`ï¼Œä¸è·¯ç”±ç”Ÿæˆå™¨ä¿æŒä¸€è‡´

ç°åœ¨ TOC æ•°æ®ç»“æ„å°†åŒ…å« `path` å­—æ®µï¼Œå¯ä»¥ä¸è·¯ç”±ç³»ç»Ÿå®Œç¾å¯¹åº”ã€‚åœ¨ `TableOfContents.tsx` ç»„ä»¶ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨ `getTocByPath(currentPath)` æ¥è·å–å½“å‰é¡µé¢çš„ TOC æ•°æ®ã€‚

---

_**User**_

æ ¹æ®æ–°çš„tocç»„ä»¶ï¼Œä¿®æ”¹å…¶æ‰‹æœºç‰ˆ #file:TableOfContents.tsx 

---

_**Assistant**_

æˆ‘çœ‹åˆ° `MobileTableOfContents.tsx` éœ€è¦æ ¹æ®æ–°çš„ `TableOfContents.tsx` ç»„ä»¶è¿›è¡Œä¿®æ”¹ã€‚ä¸»è¦é—®é¢˜æ˜¯ï¼š

1. `TableOfContents` ç»„ä»¶ç°åœ¨éœ€è¦ `currentPath` å‚æ•°
2. `MobileTableOfContents` ä¼ é€’äº† `onItemClick` å›è°ƒï¼Œä½†æ–°çš„ `TableOfContents` ç»„ä»¶ä¸æ¥å—è¿™ä¸ªå‚æ•°
3. éœ€è¦è·å–å½“å‰è·¯å¾„å¹¶ä¼ é€’ç»™ `TableOfContents`

è®©æˆ‘æ£€æŸ¥å¦‚ä½•è·å–å½“å‰è·¯å¾„ï¼š è®©æˆ‘æ£€æŸ¥ `MobileTableOfContents` æ˜¯å¦‚ä½•åœ¨çˆ¶ç»„ä»¶ä¸­ä½¿ç”¨çš„ï¼š è®©æˆ‘æŸ¥çœ‹ `App.tsx` æ¥äº†è§£å¦‚ä½•è·å–å½“å‰è·¯å¾„ï¼š ç°åœ¨æˆ‘äº†è§£äº†ç»“æ„ã€‚`MobileTableOfContents` éœ€è¦æ¥æ”¶ `currentPath` å‚æ•°å¹¶ä¼ é€’ç»™ `TableOfContents` ç»„ä»¶ã€‚å¦å¤–ï¼Œæˆ‘è¿˜éœ€è¦ä¿®æ”¹ `TableOfContents` ç»„ä»¶ä»¥æ”¯æŒ `onItemClick` å›è°ƒã€‚

é¦–å…ˆï¼Œè®©æˆ‘ä¿®æ”¹ `TableOfContents.tsx` ä»¥æ”¯æŒ `onItemClick` å›è°ƒï¼š

````tsx
import { useEffect, useState } from 'react'
import { getTocByPath, type TocItem } from '../toc-data'

interface TableOfContentsProps {
  currentPath: string
  onItemClick?: () => void
}

interface TocItemProps {
  item: TocItem
  activeId: string | null
  level: number
  onItemClick?: () => void
}

function TocItemComponent({ item, activeId, level, onItemClick }: TocItemProps) {
  const isActive = activeId === item.id
  const hasChildren = item.children && item.children.length > 0

  return (
    <li className="relative">
      <a
        href={`#${item.id}`}
        className={`
          block py-1 text-sm transition-colors duration-200
          ${
            isActive
              ? 'text-blue-600 font-medium border-l-2 border-blue-600 pl-3'
              : 'text-gray-600 hover:text-gray-900 pl-3'
          }
          ${level > 1 ? `ml-${(level - 1) * 4}` : ''}
        `}
        onClick={(e) => {
          e.preventDefault()
          const element = document.getElementById(item.id)
          if (element) {
            element.scrollIntoView({ behavior: 'smooth', block: 'start' })
          }
          onItemClick?.()
        }}
      >
        {item.text}
      </a>

      {hasChildren && (
        <ul className="mt-1 space-y-1">
          {item.children!.map((child) => (
            <TocItemComponent
              key={child.id}
              item={child}
              activeId={activeId}
              level={level + 1}
              onItemClick={onItemClick}
            />
          ))}
        </ul>
      )}
    </li>
  )
}

export function TableOfContents({ currentPath, onItemClick }: TableOfContentsProps) {
  const [activeId, setActiveId] = useState<string | null>(null)

  // è·å–å½“å‰é¡µé¢çš„ TOC æ•°æ®
  const currentToc = getTocByPath(currentPath)

  // ç›‘å¬æ»šåŠ¨ï¼Œé«˜äº®å½“å‰æ ‡é¢˜
  useEffect(() => {
    if (!currentToc || currentToc.length === 0) return

    const observer = new IntersectionObserver(
      (entries) => {
        // æ‰¾åˆ°å¯è§çš„æ ‡é¢˜ä¸­æœ€ä¸Šé¢çš„ä¸€ä¸ª
        const visibleEntries = entries.filter((entry) => entry.isIntersecting)
        if (visibleEntries.length > 0) {
          // æŒ‰ç…§åœ¨é¡µé¢ä¸­çš„ä½ç½®æ’åºï¼Œé€‰æ‹©æœ€ä¸Šé¢çš„
          visibleEntries.sort((a, b) => {
            const aRect = a.boundingClientRect
            const bRect = b.boundingClientRect
            return aRect.top - bRect.top
          })
          setActiveId(visibleEntries[0].target.id)
        }
      },
      {
        rootMargin: '-20px 0px -80% 0px',
        threshold: 0.1,
      },
    )

    // è·å–æ‰€æœ‰æ ‡é¢˜IDï¼ˆåŒ…æ‹¬åµŒå¥—çš„ï¼‰
    const getAllIds = (items: TocItem[]): string[] => {
      const ids: string[] = []
      for (const item of items) {
        ids.push(item.id)
        if (item.children) {
          ids.push(...getAllIds(item.children))
        }
      }
      return ids
    }

    const allIds = getAllIds(currentToc)

    // è§‚å¯Ÿæ‰€æœ‰æ ‡é¢˜å…ƒç´ 
    allIds.forEach((id) => {
      const element = document.getElementById(id)
      if (element) {
        observer.observe(element)
      }
    })

    return () => {
      observer.disconnect()
    }
  }, [currentToc])

  // å¦‚æœå½“å‰é¡µé¢æ²¡æœ‰TOCæ•°æ®ï¼Œä¸æ˜¾ç¤º
  if (!currentToc || currentToc.length === 0) {
    return null
  }

  return (
    <div className="sticky top-8 max-h-[calc(100vh-4rem)] overflow-auto">
      <div className="mb-4">
        <h4 className="text-sm font-semibold text-gray-900 mb-3">
          Table of Contents
        </h4>

        <nav>
          <ul className="space-y-1">
            {currentToc.map((item) => (
              <TocItemComponent
                key={item.id}
                item={item}
                activeId={activeId}
                level={1}
                onItemClick={onItemClick}
              />
            ))}
          </ul>
        </nav>
      </div>
    </div>
  )
}
````

ç°åœ¨ä¿®æ”¹ `MobileTableOfContents.tsx`ï¼š

````tsx
import { useState } from 'react'
import { TableOfContents } from './TableOfContents'

interface MobileTableOfContentsProps {
  currentPath: string
}

export function MobileTableOfContents({ currentPath }: MobileTableOfContentsProps) {
  const [isOpen, setIsOpen] = useState(false)

  return (
    <>
      {/* TOC æŒ‰é’® */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="bg-fill-primary border-separator-opaque hover:bg-fill-secondary text-text-primary fixed bottom-6 right-4 z-50 flex h-12 w-12 items-center justify-center rounded-full border shadow-lg transition-all duration-200 hover:shadow-xl xl:hidden"
        aria-label="Toggle TOC"
      >
        <svg
          className={`h-5 w-5 transition-transform duration-200 ${isOpen ? 'rotate-45' : ''}`}
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          {isOpen ? (
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M6 18L18 6M6 6l12 12"
            />
          ) : (
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M4 6h16M4 10h16M4 14h16M4 18h16"
            />
          )}
        </svg>
      </button>

      {/* TOC é¢æ¿ */}
      {isOpen && (
        <>
          {/* èƒŒæ™¯é®ç½© */}
          <div
            className="fixed inset-0 z-40 bg-black/20 backdrop-blur-sm xl:hidden"
            onClick={() => setIsOpen(false)}
          />

          {/* TOC å†…å®¹ */}
          <div className="bg-fill-primary border-separator-opaque fixed bottom-20 right-4 z-50 max-h-96 w-80 overflow-hidden rounded-2xl border shadow-2xl xl:hidden animate-in slide-in-from-bottom-4 fade-in duration-300">
            <div className="bg-fill-secondary border-separator-opaque flex items-center justify-between border-b px-4 py-3">
              <h3 className="text-text-primary text-base font-semibold">
                ç›®å½•
              </h3>
              <button
                onClick={() => setIsOpen(false)}
                className="text-text-secondary hover:text-text-primary hover:bg-fill-tertiary rounded-lg p-1.5 transition-colors"
                aria-label="Close TOC"
              >
                <svg
                  className="h-4 w-4"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
            </div>
            <div className="max-h-80 overflow-y-auto p-4">
              <TableOfContents 
                currentPath={currentPath} 
                onItemClick={() => setIsOpen(false)} 
              />
            </div>
          </div>
        </>
      )}
    </>
  )
}
````

æœ€åï¼Œéœ€è¦åœ¨ `App.tsx` ä¸­ä¼ é€’ `currentPath` ç»™ `MobileTableOfContents`ï¼š

````tsx
// éœ€è¦åœ¨ App.tsx ä¸­ä¿®æ”¹è¿™äº›è¡Œï¼š
// å°†ï¼š
<MobileTableOfContents />

// æ”¹ä¸ºï¼š
<MobileTableOfContents currentPath={currentPath} />
````

ä¸»è¦ä¿®æ”¹å†…å®¹ï¼š

1. **`TableOfContents.tsx`**ï¼š
   - æ·»åŠ å¯é€‰çš„ `onItemClick` å›è°ƒå‚æ•°
   - åœ¨ç‚¹å‡» TOC é¡¹ç›®æ—¶è°ƒç”¨è¯¥å›è°ƒ
   - é€’å½’ä¼ é€’ `onItemClick` ç»™å­é¡¹ç›®

2. **`MobileTableOfContents.tsx`**ï¼š
   - æ¥æ”¶ `currentPath` å‚æ•°å¹¶ä¼ é€’ç»™ `TableOfContents`
   - ä¿æŒåŸæœ‰çš„ `onItemClick` é€»è¾‘ä»¥å…³é—­ç§»åŠ¨ç«¯å¼¹çª—

3. **`App.tsx` éœ€è¦æ›´æ–°**ï¼š
   - åœ¨æ‰€æœ‰ä½¿ç”¨ `MobileTableOfContents` çš„åœ°æ–¹ä¼ é€’ `currentPath` å‚æ•°

è¿™æ ·ç§»åŠ¨ç«¯ TOC ç»„ä»¶å°±èƒ½æ­£ç¡®æ˜¾ç¤ºå½“å‰é¡µé¢çš„ç›®å½•ï¼Œå¹¶åœ¨ç‚¹å‡»ç›®å½•é¡¹æ—¶è‡ªåŠ¨å…³é—­å¼¹çª—äº†ã€‚

---

_**User**_

å†™ä¸€ä¸ªremark headingæ’ä»¶ï¼Œåœ¨å¤„ç†mdå’Œmdxçš„æ—¶å€™ç»™æ¯ä¸ªæ ‡é¢˜ä¸Šidï¼Œä»¥åŒ¹é…tocçš„è¿™ä¸ªid

---

_**Assistant**_

æˆ‘æ¥åˆ›å»ºä¸€ä¸ª remark æ’ä»¶ï¼Œä¸º Markdown å’Œ MDX æ–‡ä»¶ä¸­çš„æ ‡é¢˜è‡ªåŠ¨æ·»åŠ  IDï¼Œä»¥åŒ¹é… TOC æå–å™¨ç”Ÿæˆçš„ IDã€‚ è®©æˆ‘æŸ¥çœ‹ `generateHeadingId` å‡½æ•°çš„å®Œæ•´å®ç°ï¼š ç°åœ¨è®©æˆ‘æ£€æŸ¥é¡¹ç›®ä¸­æ˜¯å¦å·²ç»å®‰è£…äº†ç›¸å…³çš„ remark ä¾èµ–ï¼š å¤ªå¥½äº†ï¼é¡¹ç›®å·²ç»å®‰è£…äº†æ‰€éœ€çš„ä¾èµ–ï¼ŒåŒ…æ‹¬ `unist-util-visit` å’Œç›¸å…³çš„ç±»å‹å®šä¹‰ã€‚ç°åœ¨æˆ‘æ¥åˆ›å»º remark æ’ä»¶ï¼š

````typescript
import type { Plugin } from 'unified'
import type { Root, Heading } from 'mdast'
import { visit } from 'unist-util-visit'

/**
 * ç”Ÿæˆæ ‡é¢˜IDçš„å‡½æ•°
 * ä¿æŒä¸ toc-extractor.ts ä¸­çš„ generateHeadingId å‡½æ•°å®Œå…¨ä¸€è‡´
 */
function generateHeadingId(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^\w\s-]/g, '') // ç§»é™¤ç‰¹æ®Šå­—ç¬¦
    .replace(/\s+/g, '-') // ç©ºæ ¼æ›¿æ¢ä¸ºè¿å­—ç¬¦
    .replace(/-+/g, '-') // å¤šä¸ªè¿å­—ç¬¦åˆå¹¶ä¸ºä¸€ä¸ª
    .replace(/^-|-$/g, '') // ç§»é™¤å¼€å¤´å’Œç»“å°¾çš„è¿å­—ç¬¦
}

/**
 * ä» MDAST èŠ‚ç‚¹ä¸­æå–æ–‡æœ¬å†…å®¹
 */
function extractTextFromNode(node: any): string {
  if (typeof node === 'string') {
    return node
  }
  
  if (node.type === 'text') {
    return node.value || ''
  }
  
  if (node.type === 'inlineCode') {
    return node.value || ''
  }
  
  if (node.type === 'strong' || node.type === 'emphasis') {
    return node.children?.map(extractTextFromNode).join('') || ''
  }
  
  if (node.type === 'link') {
    return node.children?.map(extractTextFromNode).join('') || ''
  }
  
  if (node.children && Array.isArray(node.children)) {
    return node.children.map(extractTextFromNode).join('')
  }
  
  return ''
}

interface RemarkHeadingOptions {
  /**
   * æ˜¯å¦è¦†ç›–å·²å­˜åœ¨çš„ ID
   * @default false
   */
  overrideExisting?: boolean
  
  /**
   * ID å‰ç¼€
   * @default ''
   */
  prefix?: string
  
  /**
   * è‡ªå®šä¹‰ ID ç”Ÿæˆå‡½æ•°
   * @default generateHeadingId
   */
  generateId?: (text: string) => string
}

/**
 * Remark æ’ä»¶ï¼šä¸ºæ ‡é¢˜è‡ªåŠ¨æ·»åŠ  ID
 * 
 * æ­¤æ’ä»¶ä¼šéå† Markdown/MDX æ–‡æ¡£ä¸­çš„æ‰€æœ‰æ ‡é¢˜èŠ‚ç‚¹ï¼Œ
 * ä¸ºæ²¡æœ‰ ID çš„æ ‡é¢˜è‡ªåŠ¨ç”Ÿæˆ IDï¼Œç¡®ä¿ä¸ TOC æå–å™¨ç”Ÿæˆçš„ ID ä¸€è‡´
 * 
 * @param options é…ç½®é€‰é¡¹
 */
const remarkHeading: Plugin<[RemarkHeadingOptions?], Root> = (options = {}) => {
  const {
    overrideExisting = false,
    prefix = '',
    generateId = generateHeadingId
  } = options

  return (tree: Root) => {
    // ç”¨äºè·Ÿè¸ªå·²ä½¿ç”¨çš„ IDï¼Œé¿å…é‡å¤
    const usedIds = new Set<string>()

    visit(tree, 'heading', (node: Heading) => {
      // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰ ID
      const existingId = node.data?.hProperties?.id as string | undefined
      
      if (existingId && !overrideExisting) {
        usedIds.add(existingId)
        return
      }

      // æå–æ ‡é¢˜æ–‡æœ¬
      const text = node.children.map(extractTextFromNode).join('')
      
      if (!text.trim()) {
        return // è·³è¿‡ç©ºæ ‡é¢˜
      }

      // ç”ŸæˆåŸºç¡€ ID
      let baseId = prefix + generateId(text.trim())
      let finalId = baseId
      
      // å¤„ç† ID å†²çªï¼Œæ·»åŠ æ•°å­—åç¼€
      let counter = 1
      while (usedIds.has(finalId)) {
        finalId = `${baseId}-${counter}`
        counter++
      }
      
      usedIds.add(finalId)

      // è®¾ç½® ID
      if (!node.data) {
        node.data = {}
      }
      if (!node.data.hProperties) {
        node.data.hProperties = {}
      }
      
      node.data.hProperties.id = finalId
    })
  }
}

export default remarkHeading
export { remarkHeading, generateHeadingId }
````

è¿™ä¸ª remark æ’ä»¶å…·æœ‰ä»¥ä¸‹ç‰¹æ€§ï¼š

## æ ¸å¿ƒåŠŸèƒ½

1. **ä¸€è‡´çš„ ID ç”Ÿæˆ**ï¼šä½¿ç”¨ä¸ `toc-extractor.ts` å®Œå…¨ç›¸åŒçš„ `generateHeadingId` å‡½æ•°
2. **å†²çªå¤„ç†**ï¼šè‡ªåŠ¨å¤„ç† ID å†²çªï¼Œä¸ºé‡å¤çš„ ID æ·»åŠ æ•°å­—åç¼€
3. **æ–‡æœ¬æå–**ï¼šæ­£ç¡®å¤„ç†å¤æ‚çš„æ ‡é¢˜å†…å®¹ï¼ŒåŒ…æ‹¬åŠ ç²—ã€æ–œä½“ã€é“¾æ¥ã€å†…è”ä»£ç ç­‰
4. **ä¿æŠ¤ç°æœ‰ ID**ï¼šé»˜è®¤ä¸è¦†ç›–å·²å­˜åœ¨çš„ ID

## é…ç½®é€‰é¡¹

- `overrideExisting`: æ˜¯å¦è¦†ç›–å·²å­˜åœ¨çš„ ID
- `prefix`: ID å‰ç¼€
- `generateId`: è‡ªå®šä¹‰ ID ç”Ÿæˆå‡½æ•°

## ä½¿ç”¨æ–¹æ³•

åœ¨ä½ çš„ Vite/MDX é…ç½®ä¸­æ·»åŠ è¿™ä¸ªæ’ä»¶ï¼š

```typescript
// vite.config.ts
import remarkHeading from './plugins/remark-heading'

export default {
  plugins: [
    mdx({
      remarkPlugins: [
        remarkHeading,
        // æˆ–è€…å¸¦é…ç½®
        [remarkHeading, { prefix: 'heading-' }]
      ]
    })
  ]
}
```

## å…¼å®¹æ€§

- ç”Ÿæˆçš„ ID ä¸ TOC æå–å™¨å®Œå…¨ä¸€è‡´
- æ”¯æŒ Markdown å’Œ MDX
- å¤„ç†å„ç§å†…è”å…ƒç´ ï¼ˆç²—ä½“ã€æ–œä½“ã€é“¾æ¥ã€ä»£ç ç­‰ï¼‰
- è‡ªåŠ¨é¿å… ID å†²çª

è¿™æ ·ï¼Œå½“ Markdown/MDX æ–‡ä»¶è¢«å¤„ç†æ—¶ï¼Œæ‰€æœ‰æ ‡é¢˜éƒ½ä¼šè‡ªåŠ¨è·å¾—ä¸ TOC æ•°æ®åŒ¹é…çš„ IDï¼Œç¡®ä¿ TOC å¯¼èˆªåŠŸèƒ½æ­£å¸¸å·¥ä½œã€‚

---

_**User**_

æå–çš„æ—¶å€™ä¸è¦æå–ä»£ç å—é‡Œé¢çš„

---

_**Assistant**_

å¥½çš„ï¼Œæˆ‘éœ€è¦ä¿®æ”¹ `extractHeadings` å‡½æ•°ï¼Œè®©å®ƒåœ¨æå–æ ‡é¢˜æ—¶å¿½ç•¥ä»£ç å—ä¸­çš„å†…å®¹ã€‚ä»£ç å—åŒ…æ‹¬ï¼š

1. **å›´æ ä»£ç å—** (```...```)
2. **ç¼©è¿›ä»£ç å—** (4ä¸ªç©ºæ ¼æˆ–1ä¸ªTabç¼©è¿›)
3. **å†…è”ä»£ç ** (`...`)

è®©æˆ‘æ›´æ–° `toc-extractor.ts` æ–‡ä»¶ï¼š

````typescript
import fs from 'node:fs/promises'
import path from 'node:path'

import { glob } from 'glob'
import type { Plugin } from 'vite'

interface TocItem {
  id: string
  level: number
  text: string
  children?: TocItem[]
}

interface FileToc {
  file: string
  path: string
  title: string
  toc: TocItem[]
}

interface TocExtractorOptions {
  contentsDir?: string
  outputDir?: string
  outputFile?: string
  maxDepth?: number
  indexFile?: string
}

const defaultOptions: Required<TocExtractorOptions> = {
  contentsDir: 'contents',
  outputDir: 'src',
  outputFile: 'toc-data.ts',
  maxDepth: 6,
  indexFile: 'index',
}

/**
 * TOC æå–å™¨æ’ä»¶
 *
 * é€šè¿‡æ­£åˆ™è¡¨è¾¾å¼ä» MD å’Œ MDX æ–‡ä»¶ä¸­æå–æ ‡é¢˜ï¼Œç”Ÿæˆç›®å½•ç»“æ„
 * å¹¶ä¿å­˜åˆ° TypeScript æ–‡ä»¶ä¸­
 */
export function tocExtractor(options: TocExtractorOptions = {}): Plugin {
  const opts = { ...defaultOptions, ...options }

  return {
    name: 'toc-extractor',
    enforce: 'pre',

    async buildStart() {
      await generateTocData(opts)
    },

    async handleHotUpdate({ file, server }) {
      // ç›‘å¬ contents ç›®å½•æ–‡ä»¶å˜åŒ–ï¼Œé‡æ–°ç”Ÿæˆ TOC æ•°æ®
      if (file.includes(path.resolve(opts.contentsDir))) {
        await generateTocData(opts)
        server.ws.send({
          type: 'full-reload',
        })
      }
    },

    configureServer(server) {
      // å¼€å‘æ¨¡å¼ä¸‹æä¾›æ‰‹åŠ¨è§¦å‘æ¥å£
      server.middlewares.use('/__generate-toc', async (_req, res) => {
        try {
          await generateTocData(opts)
          res.end('TOC data generated successfully')
        } catch (error) {
          res.statusCode = 500
          res.end(`Error generating TOC data: ${error}`)
        }
      })
    },
  }
}

async function generateTocData(options: Required<TocExtractorOptions>) {
  const { contentsDir, outputDir, outputFile, maxDepth, indexFile } = options

  try {
    // è·å–æ‰€æœ‰ markdown æ–‡ä»¶
    const pattern = path.join(contentsDir, '**/*.{md,mdx}')
    const files = await glob(pattern, {
      ignore: ['**/node_modules/**'],
      absolute: false,
    })

    const allTocData: FileToc[] = []

    for (const file of files) {
      const tocData = await extractTocFromFile(
        file,
        contentsDir,
        maxDepth,
        indexFile,
      )
      if (tocData) {
        allTocData.push(tocData)
      }
    }

    // æŒ‰è·¯å¾„æ’åº
    allTocData.sort((a, b) => a.path.localeCompare(b.path))

    // ç”Ÿæˆ TypeScript æ–‡ä»¶å†…å®¹
    const tsContent = generateTocTsContent(allTocData)

    // ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
    await fs.mkdir(outputDir, { recursive: true })

    // å†™å…¥æ–‡ä»¶
    const outputPath = path.join(outputDir, outputFile)
    await fs.writeFile(outputPath, tsContent, 'utf-8')

    console.info(
      `âœ“ Generated TOC data for ${allTocData.length} files to ${outputPath}`,
    )
  } catch (error) {
    console.error('Error generating TOC data:', error)
    throw error
  }
}

async function extractTocFromFile(
  file: string,
  contentsDir: string,
  maxDepth: number,
  indexFile: string,
): Promise<FileToc | null> {
  try {
    const content = await fs.readFile(file, 'utf-8')

    // æå– frontmatter ä¸­çš„æ ‡é¢˜
    const frontmatterTitle = extractFrontmatterTitle(content)

    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æå–æ ‡é¢˜
    const headings = extractHeadings(content, maxDepth)

    if (headings.length === 0 && !frontmatterTitle) {
      return null
    }

    // æ„å»ºåµŒå¥—çš„ TOC ç»“æ„
    const toc = buildTocTree(headings)

    // ç”Ÿæˆæ–‡ä»¶è·¯å¾„ï¼ˆç›¸å¯¹äº contents ç›®å½•ï¼‰
    const relativePath = path.relative(contentsDir, file)

    // ç”Ÿæˆè·¯ç”±è·¯å¾„ï¼ˆä¸ route-generator ä¿æŒä¸€è‡´ï¼‰
    const routePath = generateRoutePath(file, contentsDir, indexFile)

    return {
      file: relativePath,
      path: routePath,
      title:
        frontmatterTitle ||
        headings[0]?.text ||
        path.basename(file, path.extname(file)),
      toc,
    }
  } catch (error) {
    console.warn(`Failed to process file ${file}:`, error)
    return null
  }
}

function generateRoutePath(
  file: string,
  contentsDir: string,
  indexFile: string,
): string {
  // ç§»é™¤ contents å‰ç¼€å’Œæ–‡ä»¶æ‰©å±•åï¼ˆä¸ route-generator ä¿æŒä¸€è‡´ï¼‰
  let routePath = file
    .replace(new RegExp(`^${contentsDir}/`), '')
    .replace(/\.(md|mdx)$/, '')

  // å¤„ç† index æ–‡ä»¶ï¼ˆä¸ route-generator ä¿æŒä¸€è‡´ï¼‰
  if (routePath === indexFile) {
    routePath = '/'
  } else if (routePath.endsWith(`/${indexFile}`)) {
    const basePath = routePath.replace(`/${indexFile}`, '')
    routePath = basePath ? `/${basePath}` : '/'
  } else {
    routePath = `/${routePath}`
  }

  return routePath
}

function extractFrontmatterTitle(content: string): string | null {
  // åŒ¹é… frontmatter ä¸­çš„ title å­—æ®µ
  const frontmatterMatch = content.match(/^---\n(.*?)\n---/s)
  if (!frontmatterMatch) return null

  const frontmatterContent = frontmatterMatch[1]
  const titleMatch = frontmatterContent.match(/^title:\s*(.+)$/m)
  if (!titleMatch) return null

  // ç§»é™¤å¼•å·
  return titleMatch[1].replace(/^['"]|['"]$/g, '').trim()
}

/**
 * ç§»é™¤å†…å®¹ä¸­çš„ä»£ç å—
 * åŒ…æ‹¬å›´æ ä»£ç å— (```...```) å’Œç¼©è¿›ä»£ç å—
 */
function removeCodeBlocks(content: string): string {
  // 1. ç§»é™¤å›´æ ä»£ç å— (```...``` æˆ– ~~~...~~~)
  let result = content.replace(/^```[\s\S]*?^```$/gm, '')
  result = result.replace(/^~~~[\s\S]*?^~~~$/gm, '')
  
  // 2. ç§»é™¤ç¼©è¿›ä»£ç å— (è¿ç»­çš„4ç©ºæ ¼æˆ–1Tabç¼©è¿›çš„è¡Œ)
  const lines = result.split('\n')
  const filteredLines: string[] = []
  let inCodeBlock = false
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i]
    const isCodeLine = /^(    |\t)/.test(line) && line.trim() !== ''
    const isEmptyLine = line.trim() === ''
    
    if (isCodeLine) {
      inCodeBlock = true
      continue // è·³è¿‡ä»£ç è¡Œ
    }
    
    if (inCodeBlock && isEmptyLine) {
      // åœ¨ä»£ç å—ä¸­çš„ç©ºè¡Œï¼Œæ£€æŸ¥ä¸‹ä¸€è¡Œæ˜¯å¦è¿˜æ˜¯ä»£ç 
      let nextNonEmptyIndex = i + 1
      while (nextNonEmptyIndex < lines.length && lines[nextNonEmptyIndex].trim() === '') {
        nextNonEmptyIndex++
      }
      
      if (nextNonEmptyIndex < lines.length && /^(    |\t)/.test(lines[nextNonEmptyIndex])) {
        // ä¸‹ä¸€ä¸ªéç©ºè¡Œè¿˜æ˜¯ä»£ç ï¼Œè·³è¿‡è¿™ä¸ªç©ºè¡Œ
        continue
      } else {
        // ä»£ç å—ç»“æŸ
        inCodeBlock = false
      }
    }
    
    if (!isCodeLine) {
      inCodeBlock = false
    }
    
    filteredLines.push(line)
  }
  
  return filteredLines.join('\n')
}

function extractHeadings(content: string, maxDepth: number): TocItem[] {
  const headings: TocItem[] = []

  // é¦–å…ˆç§»é™¤æ‰€æœ‰ä»£ç å—
  const contentWithoutCodeBlocks = removeCodeBlocks(content)

  // æ­£åˆ™è¡¨è¾¾å¼åŒ¹é… Markdown æ ‡é¢˜ (## Title æ ¼å¼)
  const headingRegex = /^(#{1,6})\s+(.+)$/gm

  let match
  while ((match = headingRegex.exec(contentWithoutCodeBlocks)) !== null) {
    const level = match[1].length

    if (level > maxDepth) continue

    const text = match[2].trim()

    // ç”Ÿæˆ IDï¼ˆè½¬æ¢ä¸ºå°å†™ï¼Œæ›¿æ¢ç©ºæ ¼å’Œç‰¹æ®Šå­—ç¬¦ï¼‰
    const id = generateHeadingId(text)

    headings.push({
      id,
      level,
      text,
    })
  }

  return headings
}

function generateHeadingId(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^\w\s-]/g, '') // ç§»é™¤ç‰¹æ®Šå­—ç¬¦
    .replace(/\s+/g, '-') // ç©ºæ ¼æ›¿æ¢ä¸ºè¿å­—ç¬¦
    .replace(/-+/g, '-') // å¤šä¸ªè¿å­—ç¬¦åˆå¹¶ä¸ºä¸€ä¸ª
    .replace(/^-|-$/g, '') // ç§»é™¤å¼€å¤´å’Œç»“å°¾çš„è¿å­—ç¬¦
}

function buildTocTree(headings: TocItem[]): TocItem[] {
  const result: TocItem[] = []
  const stack: TocItem[] = []

  for (const heading of headings) {
    // å°†å½“å‰æ ‡é¢˜çš„å­å…ƒç´ åˆå§‹åŒ–ä¸ºç©ºæ•°ç»„
    heading.children = []

    // æ‰¾åˆ°åˆé€‚çš„çˆ¶çº§
    while (stack.length > 0 && stack[stack.length - 1].level >= heading.level) {
      stack.pop()
    }

    if (stack.length === 0) {
      // é¡¶çº§æ ‡é¢˜
      result.push(heading)
    } else {
      // ä½œä¸ºå­æ ‡é¢˜
      const parent = stack[stack.length - 1]
      if (!parent.children) {
        parent.children = []
      }
      parent.children.push(heading)
    }

    stack.push(heading)
  }

  return result
}

function generateTocTsContent(tocData: FileToc[]): string {
  return `// This file is automatically generated by the toc-extractor plugin
// Do not edit manually

export interface TocItem {
  id: string
  level: number
  text: string
  children?: TocItem[]
}

export interface FileToc {
  file: string
  path: string
  title: string
  toc: TocItem[]
}

export const tocData: FileToc[] = ${JSON.stringify(tocData, null, 2)}

// Helper function to find TOC data by file path
export function getTocByFile(filePath: string): TocItem[] | undefined {
  const item = tocData.find(item => item.file === filePath)
  return item?.toc
}

// Helper function to find TOC data by route path
export function getTocByPath(routePath: string): TocItem[] | undefined {
  const item = tocData.find(item => item.path === routePath)
  return item?.toc
}

// Helper function to flatten TOC tree into a simple array
export function flattenToc(toc: TocItem[]): TocItem[] {
  const result: TocItem[] = []
  
  function traverse(items: TocItem[]) {
    for (const item of items) {
      result.push({
        id: item.id,
        level: item.level,
        text: item.text,
      })
      if (item.children && item.children.length > 0) {
        traverse(item.children)
      }
    }
  }
  
  traverse(toc)
  return result
}

// Helper function to get all headings at a specific level
export function getHeadingsByLevel(toc: TocItem[], level: number): TocItem[] {
  const result: TocItem[] = []
  
  function traverse(items: TocItem[]) {
    for (const item of items) {
      if (item.level === level) {
        result.push(item)
      }
      if (item.children && item.children.length > 0) {
        traverse(item.children)
      }
    }
  }
  
  traverse(toc)
  return result
}
`
}

export default tocExtractor
````

ä¸»è¦æ”¹åŠ¨ï¼š

## æ–°å¢ `removeCodeBlocks` å‡½æ•°

è¿™ä¸ªå‡½æ•°è´Ÿè´£ç§»é™¤ Markdown å†…å®¹ä¸­çš„æ‰€æœ‰ä»£ç å—ï¼š

1. **å›´æ ä»£ç å—**ï¼šä½¿ç”¨ `^```[\s\S]*?^```$` å’Œ `^~~~[\s\S]*?^~~~$` æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…å’Œç§»é™¤ä¸‰ä¸ªåå¼•å·æˆ–æ³¢æµªå·åŒ…å›´çš„ä»£ç å—

2. **ç¼©è¿›ä»£ç å—**ï¼šé€è¡Œæ£€æŸ¥ï¼Œç§»é™¤ä»¥4ä¸ªç©ºæ ¼æˆ–1ä¸ªTabå¼€å¤´çš„è¿ç»­è¡Œï¼ŒåŒæ—¶æ­£ç¡®å¤„ç†ä»£ç å—ä¸­çš„ç©ºè¡Œ

## ä¿®æ”¹ `extractHeadings` å‡½æ•°

åœ¨æå–æ ‡é¢˜ä¹‹å‰ï¼Œå…ˆè°ƒç”¨ `removeCodeBlocks` å‡½æ•°æ¸…ç†å†…å®¹ï¼Œè¿™æ ·å¯ä»¥ç¡®ä¿ï¼š

- ä»£ç å—ä¸­çš„ `# æ³¨é‡Š` ä¸ä¼šè¢«è¯¯è®¤ä¸ºæ˜¯æ ‡é¢˜
- ä»£ç ç¤ºä¾‹ä¸­çš„ Markdown è¯­æ³•ä¸ä¼šå¹²æ‰° TOC ç”Ÿæˆ
- åªæå–çœŸæ­£çš„æ–‡æ¡£æ ‡é¢˜

## å¤„ç†è¾¹ç•Œæƒ…å†µ

- **ç©ºè¡Œå¤„ç†**ï¼šæ­£ç¡®è¯†åˆ«ä»£ç å—ä¸­çš„ç©ºè¡Œï¼Œé¿å…å°†ä»£ç å—æ‹†åˆ†
- **åµŒå¥—ç»“æ„**ï¼šæ”¯æŒä»£ç å—å†…çš„å¤æ‚ç»“æ„
- **å¤šç§ä»£ç å—æ ¼å¼**ï¼šåŒæ—¶æ”¯æŒå›´æ ä»£ç å—å’Œç¼©è¿›ä»£ç å—

è¿™æ ·ä¿®æ”¹åï¼ŒTOC æå–å™¨å°±ä¸ä¼šä»ä»£ç å—ä¸­æå–æ ‡é¢˜äº†ï¼Œåªä¼šæå–çœŸæ­£çš„æ–‡æ¡£ç»“æ„æ ‡é¢˜ã€‚

---

